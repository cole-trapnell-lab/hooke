{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Hooke is a new software package that uses Poisson-Lognormal models to perform differential analysis of cell abundances for perturbation experiments read out by single-cell RNA-seq. This versatile framework allows users to both perform multivariate statistical regression to describe how perturbations alter the relative abundances of each cell state and visualize cell type abundance kinetics. </p> <p></p>"},{"location":"about/","title":"Differential abundance","text":"<p>Hooke can identify differentially abundant cell types for a given contrast. The underlying PLN model mimics the standard (G)LM-like interface of <code>R::stats</code>. This allows users to fit a multivariate Poisson lognormal model after correcting for effects of offsets and covariates. This framework allows users to perform multivariate statistical regression to describe how perturbations alter the relative abundances of each cell state. For example, you could model the effects of genotype (WT vs MT) while controlling for experimental batch. </p>"},{"location":"about/#analysis-of-differentially-abundant-cell-types-in-silicosis-with-hooke","title":"Analysis of differentially abundant cell types in silicosis with Hooke","text":"<p>This data was published in Hasegawa, Franks, et al. bioRxiv.  The authors performed a longitudinal transcriptomic analysis using scRNA-sequencing of the lungs from pre- and post-silica challenged mice. </p> <p>The data includes 12 whole lung samples across pre- and post- intratracheal silica. 35 unique cell states were identified using highly and specifically expressed marker genes. For simplicity, we are splitting samples into 2 levels: exposed and not exposed. The goal is to identify which cell types are differentially abundant post-silica exposure. </p> <pre><code>cds = readRDS(\"silicosis_cds.rds\")\n\n# for simplicity, we are lumping together pre and post i.t. silica\ncolData(cds)$exposed = ifelse(colData(cds)$Timepoint == 0, \"not exposed\", \"exposed\")\ncolData(cds)$Rep = as.factor(colData(cds)$Rep)\n\nplot_cells(cds, color_cells_by = \"fine_annotation\", label_groups_by_cluster = F)\n\n</code></pre> <p></p>"},{"location":"about/#making-a-cell-count-set-object","title":"Making a cell count set object","text":"<p>The first step of Hooke is to create a <code>cell_count_set</code> object. This requires three inputs: </p> <ul> <li><code>cds</code> - a monocle3 <code>cell_data_set</code> object</li> <li><code>sample group</code> -  A column in <code>colData(cds)</code> that specifies how cells are grouped into samples</li> <li><code>cell group</code> - A column in <code>colData(cds)</code> that specifies how cells are grouped into types or states (e.g. cluster)</li> </ul> <pre><code>ccs = new_cell_count_set(cds, \n                         sample_group = \"ID\", \n                         cell_group = \"fine_annotation\")\n</code></pre>"},{"location":"about/#fitting-a-cell-count-model","title":"Fitting a cell count model","text":"<p>The next step is to fit a <code>cell_count_model</code> given a model formula. This function works with the standard <code>R formula</code> notations. </p> <p>A cell count model requires the following inputs: </p> <ul> <li><code>ccs</code> - a Hooke <code>cell_count_set</code> object</li> <li><code>main_model_formula_str</code> -  A character string specifying the model of cell abundances across samples, where terms refer to columns in <code>colData(ccs)</code>. Put main effects here.</li> <li><code>nuisance_model_formula_str</code> - A character string specifying the model of cell abundances across samples. Put nuisance effects here.</li> </ul> <p>In this case we are interested in comparing silica exposed mouse lungs to unexposed lungs. </p> <pre><code>ccm  = new_cell_count_model(ccs,\n                            main_model_formula_str = \"~ exposed\")\n</code></pre>"},{"location":"about/#estimating-abundances","title":"Estimating abundances","text":"<p>Next we can predict fold change values for a given contrast of interest using <code>estimate_abundances()</code>.  </p> <ul> <li><code>ccm</code> - a Hooke <code>cell_count_model</code> object</li> <li><code>newdata</code> - A tibble of variables used for the prediction.</li> <li><code>min_log_abund</code> - numeric Minimum log abundance value.</li> </ul> <pre><code>cond_exp = estimate_abundances(ccm, tibble::tibble(exposed = \"exposed\"))\ncond_not_exp = estimate_abundances(ccm, tibble::tibble(exposed = \"not exposed\"))\n\ncond_not_exp %&gt;% head()\n</code></pre> exposed cell_group log_abund log_abund_se log_abund_sd not exposed Endothelial Arterial 2.87 0.196 0.559 not exposed Endothelial Capillary 5.31 0.0591 0.559 not exposed Endothelial Venous 3.09 0.179 0.559 not exposed Lymphatic Endothelial 2.63 0.213 0.559 not exposed Aerocytes 4.06 0.110 0.559 not exposed Fibroblasts 5.26 0.0607 0.559"},{"location":"about/#comparing-abundances","title":"Comparing abundances","text":"<p>And then compare two estimates of cell abundances from a Hooke model to identify significant changes with <code>compare_abundances()</code>. In this case, exposed vs not exposed. </p> <ul> <li><code>ccm</code> - a Hooke <code>cell_count_model</code> object</li> <li><code>cond_x</code> - A cell type abundance estimate from estimate_abundances().</li> <li><code>cond_y</code> - A cell type abundance estimate from estimate_abundances().</li> </ul> <pre><code>cond_ne_v_e_tbl = compare_abundances(ccm, cond_not_exp, cond_exp)\n\ncond_ne_v_e_tbl %&gt;% select(cell_group, exposed_x, exposed_y,\n                           delta_log_abund, delta_log_abund_se, delta_q_value)\n\n</code></pre> cell_group delta_log_abund delta_log_abund_se delta_q_value Endothelial Arterial -0.584 0.196 0.0774 Endothelial Capillary -0.400 0.0769 0.0131 Endothelial Venous -0.353 0.145 0.130 Lymphatic Endothelial 0.0529 0.330 0.989 Aerocytes -0.354 0.130 0.102 Fibroblasts -0.477 0.102 0.0131"},{"location":"about/#plotting-differential-abundance-changes-on-a-umap","title":"Plotting differential abundance changes on a UMAP","text":"<p>Finally, we can color our UMAP by the fold changes we estimate in <code>compare_abundances()</code> using the <code>plot_contrast()</code> function. We can select fold changes that are signifiant given a <code>q_value_thresh</code>. </p> <ul> <li><code>ccm</code> - A Hooke <code>cell_count_model</code> object.</li> <li><code>cond_b_vs_a_tbl</code> - A data frame from <code>compare_abundances()</code>.</li> <li><code>log_abundance_thresh</code> - numeric Select cell groups by log abundance.</li> <li><code>q_value_thresh</code> - Remove contrasts whose change in q-value exceeds <code>q_value_thresh</code>.</li> </ul> <pre><code>plot_contrast(ccm, cond_ne_v_e_tbl, q_value_thresh = 0.05)\n</code></pre> <p></p>"},{"location":"about/#controlling-for-batch-terms","title":"Controlling for batch terms","text":"<p>If your data contains multiple experimental batch, Hooke supports batch correction with the use of a nuisance model string term. </p> <pre><code>ccm_rep  = new_cell_count_model(ccs,\n                            main_model_formula_str = \"~ exposed\",\n                            nuisance_model_formula_str = \"~ Rep\")\n\ncond_exp_rep = estimate_abundances(ccm_rep, tibble::tibble(exposed = \"exposed\", Rep = \"1\"))\ncond_not_exp_rep = estimate_abundances(ccm_rep, tibble::tibble(exposed = \"not exposed\", Rep = \"1\"))\ncond_ne_v_e_tbl_rep = compare_abundances(ccm_rep, cond_not_exp_rep, cond_exp_rep)\n\nplot_contrast(ccm_rep, cond_ne_v_e_tbl_rep, q_value_thresh = 0.05)\n</code></pre> <p>If we control for replicate, we see some difference in significant fold changes. </p> <p></p>"},{"location":"advanced/","title":"Analyzing time series perturbation data with Hooke","text":"<p>Hooke can be used to analyze data with multiple time points across perturbations, such as the data found in  Saunders, Srivatsan, et al. Nature, in press (2023). This study in includes ~3 million single cells across almost 2000 individual barcoded embryos. It includes 19 timepoints (18-96 hpf) and 23 genetic loss of function experiments. For more information see the ZSCAPE website. </p>"},{"location":"advanced/#analysis-of-cranial-sensory-ganglia-with-hooke","title":"Analysis of cranial sensory ganglia with Hooke","text":"<p>This vignette focuses on the cranial sensory ganglia subset. Cranial sensory neurons transmit information from the head, ear, heart and viscera. Around 30,000 cranial sensory neurons (~20 cells/embryo) were identified. These cells were annotated by comparing branch specific gene expression with published expression data.</p> <p></p>"},{"location":"advanced/#fitting-a-hooke-model-with-model-time-points","title":"Fitting a Hooke model with model time points","text":"<p>Foxi1 and phox2a are two transcription factors important for cranial sensory ganglia development. Here we subset the <code>cds</code> to focus on those perturbations. We also include all the controls in our <code>cell count set</code> construction. </p> <pre><code>\ncontrol_ids = c(\"ctrl-uninj\", \"ctrl-inj\", \"ctrl-hgfa\", \"ctrl-met\", \"ctrl-mafba\", \"ctrl-noto\", \"ctrl-tbx16\")\ncds = cds[, colData(cds)$gene_target %in% c(\"phox2a\", \"foxi1\", control_ids)]\n\ncolData(cds)$perturbation = ifelse(colData(cds)$gene_target %in% control_ids, \n                                   \"control\", \n                                   colData(cds)$gene_target) \n\nccs = new_cell_count_set(cds, \n                         sample_group = \"embryo\", \n                         cell_group = \"cell_type_sub\")\n</code></pre> <p>The function<code>build_interval_formula()</code> builds a model formula for time series models based on the range of the data. This is a utility function that puts the knots in reasonable positions based on the range of the data. It takes the following as input: </p> <ul> <li><code>ccs</code>- a Hooke <code>cell_count_set</code> object. </li> <li><code>num_breaks</code> - specifies degrees of freedom</li> <li><code>interval_var</code> - name of the column that the interval should be based on </li> <li><code>interval_start</code>- defaults to the <code>min(interval_var)</code> value</li> <li><code>interval_stop</code> - defaults to the <code>max(interval_var)</code> value</li> </ul> <p>Note: if using this function or specifying your own spline, you must load <code>library(spline)</code>. Putting <code>splines::ns()</code> in your model formula will result in an error as the model reads it as an interaction term.</p> <pre><code>start_time = 18\nstop_time = 72\ntime_formula = build_interval_formula(ccs, num_breaks = 3, interval_start = 18, interval_stop = 72)\n</code></pre> <p>The resulting time formula is <code>~ ns(timepoint , knots= c(45))</code></p> <p>We can fit a <code>cell_count_model</code> using this time formula and a perturbation term... </p> <pre><code>ccm = new_cell_count_model(ccs, \n                           main_model_formula_str = paste0(time_formula, \"+ perturbation\"))\n\n# predict for 48 hpf \ncond_wt = estimate_abundances(ccm, tibble(timepoint = 48, perturbation = \"control\"))\ncond_phox2a = estimate_abundances(ccm, tibble(timepoint = 48, perturbation = \"phox2a\"))\ncond_foxi1 = estimate_abundances(ccm, tibble(timepoint = 48, perturbation = \"foxi1\"))\n\nwt_v_phox2a_tbl = compare_abundances(ccm, cond_wt, cond_phox2a)\nwt_v_foxi1_tbl = compare_abundances(ccm, cond_wt, cond_foxi1)\n</code></pre> <p>... and plot the abundance changes. </p> <pre><code>plot_contrast(ccm, wt_v_phox2a_tbl, x=1, y=3, q_value_thresh = 0.05)\n</code></pre> <p></p>"},{"location":"advanced/#using-hooke-time-intervals-to-view-kinetics","title":"Using Hooke time intervals to view kinetics","text":"<p>We can use Hooke to view when cell types are at their peak abundance in the dataset. Here we are just looking at wild-type data and estimating abundances over a time interval. </p> <pre><code>\nwt_cds = cds[, colData(cds)$gene_target %in% control_ids]\nwt_ccs = new_cell_count_set(wt_cds, \n                           sample_group = \"embryo\", \n                           cell_group = \"cell_type_sub\")\n\ncolData(wt_ccs)$timepoint = as.numeric(colData(wt_ccs)$timepoint)\nwt_ccm = new_cell_count_model(wt_ccs, \n                              main_model_formula_str = \"ns(timepoint, df=3)\")\n\nwt_timepoint_pred_df = estimate_abundances_over_interval(wt_ccm, \n                                                         interval_start=18, \n                                                         interval_stop=72, \n                                                         interval_col=\"timepoint\", \n                                                         interval_step=2)\n\nlog_abund_detection_thresh=-3\n\nggplot(wt_timepoint_pred_df, aes(x = timepoint)) +\n  geom_line(aes(y = exp(log_abund) + exp(log_abund_detection_thresh))) +\n  facet_wrap(~cell_group, scales=\"free_y\") + monocle3:::monocle_theme_opts()\n\n</code></pre> <p></p>"},{"location":"advanced/#controlling-for-batch-effects","title":"Controlling for batch effects","text":"<p>If the data was collected in multiple batches, you can also include a <code>nuisance_model_formula_str</code> and plot each experimental batch's kinetics. </p> <pre><code>\nwt_expt_ccm = new_cell_count_model(wt_ccs, \n                                   main_model_formula_str = \"ns(timepoint, df=3)\", \n                                   nuisance_model_formula_str = \"~ expt\")\n\nbatches = data.frame(batch = unique(colData(wt_ccs)$expt))                                   \nbatches = batches %&gt;% mutate(tp_preds = purrr::map(.f = function(batch) {\n estimate_abundances_over_interval(wt_expt_ccm,\n                                            start_time,\n                                            stop_time,\n                                            knockout=FALSE,\n                                            interval_col=\"timepoint\",\n                                            interval_step=2,\n                                            tibble(expt = batch))\n}, .x=batch))\n\nwt_timepoint_pred_df = batches %&gt;% select(tp_preds) %&gt;% tidyr::unnest(tp_preds)\n\nggplot(wt_timepoint_pred_df, aes(x = timepoint)) +\n  geom_line(aes(y = exp(log_abund) + exp(log_abund_detection_thresh), color=expt)) +\n  facet_wrap(~cell_group, scales=\"free_y\", nrow = 2) + monocle3:::monocle_theme_opts() + \n  ggtitle(\"wild-type kinetics by expt\")\n\n</code></pre> <p></p>"},{"location":"advanced/#perturbation-kinetics","title":"Perturbation kinetics","text":"<p>We can also plot a given perturbation's kinetics against the wild type. </p> <pre><code>\ntfap2afoxd3_cds = cds[, colData(cds)$gene_target %in% c(\"tfap2a-foxd3\", control_ids)]\n\ncolData(tfap2afoxd3_cds)$gene_target = ifelse(colData(tfap2afoxd3_cds)$gene_target %in% control_ids, \n                                              \"control\", colData(tfap2afoxd3_cds)$gene_target)\n\ntfap2afoxd3_ccs = new_cell_count_set(tfap2afoxd3_cds, \n                                     sample_group = \"embryo\", \n                                     cell_group = \"cell_type_sub\")\n\ncolData(tfap2afoxd3_ccs)$timepoint = as.numeric(colData(tfap2afoxd3_ccs)$timepoint)\n\n\nstart_time = 18\nstop_time = 72\n\ntime_formula = build_interval_formula(tfap2afoxd3_ccs, num_breaks = 3, interval_start = 18, interval_stop = 72)\n\n\ntfap2afoxd3_ccm = new_cell_count_model(tfap2afoxd3_ccs, \n                                .     main_model_formula_str = paste0(time_formula, \"* perturbation\" ))\n\nwt_timepoint_pred_df = estimate_abundances_over_interval(tfap2afoxd3_ccm, \n                                                                 interval_start=start_time, \n                                                                 interval_stop=stop_time, \n                                                                 interval_col=\"timepoint\", \n                                                                 interval_step=2, \n                                                                 tibble(perturbation = \"control\"))\n\nko_timepoint_pred_df = estimate_abundances_over_interval(tfap2afoxd3_ccm, \n                                                                 interval_start=start_time, \n                                                                 interval_stop=stop_time, \n                                                                 interval_col=\"timepoint\", \n                                                                 interval_step=2, \n                                                                 tibble(perturbation = \"tfap2a-foxd3\"))\ntimepoints = seq(start_time, stop_time, 2)\nperturb_vs_wt_nodes = tibble(t1=timepoints) %&gt;%\n  mutate(comp_abund = purrr::map(.f = compare_ko_to_wt_at_timepoint,\n                                 .x = t1,\n                                 perturbation_ccm=tfap2afoxd3_ccm,\n                                 interval_col=\"timepoint\",\n                                 wt_pred_df = wt_timepoint_pred_df,\n                                 ko_pred_df = ko_timepoint_pred_df)) %&gt;% \n  tidyr::unnest(comp_abund)\n\nlog_abund_detection_thresh=-3\n\nggplot(perturb_vs_wt_nodes, aes(x = t1)) +\n  geom_line(aes(y = exp(log_abund_x) + exp(log_abund_detection_thresh), linetype = \"Wild-type\")) +\n  geom_line(aes(y = exp(log_abund_y) + exp(log_abund_detection_thresh), linetype = \"Knockout\")) +\n  ggh4x::stat_difference(aes(ymin = exp(log_abund_x)+exp(log_abund_detection_thresh), ymax = exp(log_abund_y) +exp(log_abund_detection_thresh)), alpha=0.3) + \n  facet_wrap(~cell_group, scales=\"free_y\", nrow=2) + monocle3:::monocle_theme_opts() + ggtitle(\"tfap2afoxd3 kinetics\")\n\n\n</code></pre> <p></p>"},{"location":"background/","title":"Background","text":"<p>Hooke is implemented using the PLNmodels package. PLN models are a multivariate mixed generalized linear model with a Poisson distribution, allowing them to overcome the computational challenges posed by count data. They provide a convenient framework to perform multivariate statistical regression to describe how environmental effects or perturbations alter the relative abundances of each species.</p>"},{"location":"background/#references","title":"References","text":"<ol> <li> <p>J. Chiquet, M. Mariadassou and S. Robin: The Poisson-lognormal model as a versatile framework for the joint analysis of species abundances, Frontiers in Ecology and Evolution, 2021.</p> </li> <li> <p>J. Chiquet, M. Mariadassou and S. Robin: Variational inference for sparse network reconstruction from count data, Proceedings of the 36th International Conference on Machine Learning (ICML), 2019.</p> </li> <li> <p>J. Chiquet, M. Mariadassou and S. Robin: Variational inference for probabilistic Poisson PCA, the Annals of Applied Statistics, 12: 2674\u20132698, 2018.</p> </li> </ol>"},{"location":"data/","title":"Example datasets","text":"<p>Descriptions and download links for the datasets used in the Hooke vignettes.  </p>"},{"location":"data/#silica-induced-pulmonary-fibrosis-mouse","title":"Silica-induced pulmonary fibrosis [mouse]:","text":"<p>Silicosis data (.RDS)</p> <p>Subclustered and finely annotated whole-lung single-nucleas RNA sequencing from a silica-induced pulmonary fibrosis mouse model. </p> <p>This studied was published in Hasegawa, Franks, et al. bioRxiv, (2023)</p>"},{"location":"data/#cell-metadata-breakdown","title":"Cell metadata breakdown","text":"<p>Important columns in this data: </p> <ul> <li><code>ID</code> - individual sample ID. </li> <li><code>Timepoint</code> - timepoint the lung was sampled. </li> <li><code>Rep</code> - replicate</li> <li><code>fine_annotation</code> - The finest cell type annotation level.</li> <li><code>broad_annotation</code> - A broader level of cell type annotation than <code>cell_type_sub</code>, but still capturing all uniquely identified cell types.</li> </ul>"},{"location":"data/#cranial-sensory-ganglia-zebrafish","title":"Cranial sensory ganglia [zebrafish]:","text":"<p>Subclustered and finely annotated sensory cranial ganglia cells (plus Rohon-Beard neurons). This dataset contains just wild type and control-injected cells.  </p> <p>Cranial ganglia subset (.RDS)</p> <p>Our findings are published in Saunders, Srivatsan, et al. Nature, in press (2023). For more information about this dataset, see the ZSCAPE website. </p>"},{"location":"data/#cell-metadata-breakdown_1","title":"Cell metadata breakdown","text":"<p>Our cell metadata contains lots of information about time, perturbation, statistical metrics, and annotation. Here is a breakdown of those attributes according to our column names:</p> <ul> <li><code>timepoint</code>: The developmental stage in hours post fertilization (hpf) of embryos. Embryos were staged according to key landmarks according to (Kimmel, et al (1995)). Options are 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 72, and 96 hpf.</li> <li><code>expt</code>: Denotes unique library preparation instances.</li> <li><code>cell_type_sub</code>: The finest cell type annotation level.</li> <li><code>cell_type_broad</code>: A broader level of cell type annotation than <code>cell_type_sub</code>, but still capturing all uniquely identified cell types.</li> <li><code>tissue</code>: The tissue type annotation that contains the cell types.</li> <li><code>germ_layer</code>: The germ layer of origin for each cell type, if known.</li> <li><code>gene_target</code>: The genetic perturbation target. Controls include injected (scrambled) and unjected. Sibling controls are listed as <code>ctrl-&lt;target&gt;</code>, for null mutants included in the study.</li> <li><code>mean_nn_time</code>: The mean time points of the nearest 15 neighbor cells</li> <li><code>embryo</code>: The individual embryo barcode.</li> <li><code>temp</code>: The growth temperature of the embryos (standard conditions are 28C).</li> <li><code>pseudostage</code>: Embryo-level staging prediction by cell composition.</li> </ul>"},{"location":"data_type/","title":"Data Type Requirements","text":""},{"location":"data_type/#data-type-requirements","title":"Data type requirements","text":"<p>Hooke is built for experiments with multiple treatments and replicates, taking advantage of replicates in various groups or perturbations. As input, Hooke takes in a cell x gene matrix where cells are annotated according to type (or cluster) and by which sample or specimen they came from. It will aggregate cells according to type and by sample. This collapses the matrix into a new, smaller matrix where rows are cell types and the columns denote how many cells of that type were present in each sample. We refer to this as a cell type abundance matrix. </p> <p></p>"},{"location":"data_type/#using-a-monocle3-object","title":"Using a Monocle3 object","text":"<p>Hooke extends the cell data count set. A Monocle3 object can be directly plugged into Hooke. </p>"},{"location":"data_type/#using-a-seurat-object","title":"Using a Seurat object","text":"<p>Currently Hooke only supports Monocle3 cell data set objects. If using Seurat, please see the Seurat documentation on how to convert a Seurat object to a Monocle3 object. </p>"},{"location":"deg/","title":"Differential Expression","text":""},{"location":"deg/#pseudobulking","title":"Pseudobulking","text":"<p>Expression values are aggregated for each embryo each cell into \"pseudo-cells\". </p> <p></p> <p>The aggregation matches that of the <code>ccs</code>. </p> <ul> <li><code>ccs</code> - a Hooke <code>cell_count_set</code> object. </li> </ul> <pre><code>pb_cds = pseudobulk_ccs_for_states(ccs)\n</code></pre> <p>To add a column from the <code>colData(ccs)</code>, use the <code>add_covariate()</code> function. It requires three inputs: </p> <ul> <li><code>ccs</code> - a Hooke <code>cell_count_set</code> object. </li> <li><code>pb_cds</code> - a pseudobulked-cds from <code>pseudobulk_ccs_for_states</code>.</li> <li><code>covariate</code> - a column to add from the <code>colData(ccs)</code>.</li> </ul> <pre><code># this covariate we are adding will be required for our future model formula \npb_cds = add_covariate(ccs, pb_cds, \"exposed\")\n</code></pre>"},{"location":"deg/#finding-top-markers","title":"Finding top markers","text":"<p>We can identify top markers for each cell type in the <code>ccs</code>. See the monocle3 website for more in-depth documentation on how to use <code>top_markers()</code>. </p> <pre><code># subset to control cells only\nwt_pb_cds = pb_cds[, colData(pb_cds)$perturbation == \"not exposed\"]\n\nmarker_test_res = top_markers(wt_pb_cds, group_cells_by = \"cell_group\")\n\ntop_specific_markers &lt;- marker_test_res %&gt;%\n  filter(fraction_expressing &gt;= 0.10) %&gt;%\n  group_by(cell_group) %&gt;%\n  top_n(1, pseudo_R2)\n\ntop_specific_marker_ids &lt;- unique(top_specific_markers %&gt;% pull(gene_id))\n\nplot_genes_by_group(wt_pb_cds,\n                    top_specific_marker_ids,\n                    group_cells_by=\"cell_group\",\n                    ordering_type=\"maximal_on_diag\",\n                    max.size=3)\n</code></pre> <p></p>"},{"location":"deg/#running-fit-models","title":"Running fit models","text":"<p>We have modified the <code>fit_models</code> function in Monocle3 to take a <code>weights</code> argument which is the number of cells in each group. This allows the number of observations to reflect the number of cells, not just the number of pseudobulks. Here, we test one cell type that came up as significantly differentially abundant, <code>Fibr-2 Macrophages</code>. See the monocle3 website for more in-depth documentation on how to use <code>fit_models()</code>. </p> <pre><code># subset the pseudobulked cds to one cell type\nfm_pb_cds = pb_cds[, colData(pb_cds)$cell_group %in% c(\"Fibr-2 Macrophages\")]\n\n# test for differentially expressed genes between silica exposed and control Fibr-2 macrophages\ngene_fits &lt;- fit_models(fm_pb_cds, \n                        model_formula_str = \"~exposed\", \n                        weights=colData(fm_pb_cds)$num_cells_in_group)\n\nfit_coefs &lt;- coefficient_table(fm_gene_fits)  \n\nFM_genes = fit_coefs %&gt;% \n              filter(grepl(\"exposed\", term)) %&gt;% \n              filter (q_value &lt; 0.05) %&gt;%\n              select(gene_short_name, term, q_value, estimate) %&gt;% \n              pull(gene_short_name)\n\n\nplot_genes_violin(fm_pb_cds[rowData(fm_pb_cds)$gene_short_name %in% FM_genes,], \n                  group_cells_by=\"perturbation\", ncol=length(FM_genes)) +\n  theme(axis.text.x=element_text(angle=45, hjust=1))\n\n</code></pre> <p></p>"},{"location":"install/","title":"Installation","text":"<p>Hooke runs in the R statistical computing environment. It requires R &gt;= 3.5.0. Hooke is currently only available for Github install. </p> <p>NOTE: Hooke is currently in the beta phase of its development. The documentation on this page is also still under construction. Not all features currently implemented have been completely documented. Please report any issues to your github page. </p>"},{"location":"install/#required-software","title":"Required software","text":"<p>Hooke builds on top of the Monocle3 package. </p> <pre><code>devtools::install_github(\"cole-trapnell-lab/monocle3\")\n</code></pre> <p>Hooke depends on the PLNmodels package.  You can install as follows: </p> <pre><code>remotes::install_github(\"pln-team/PLNmodels\")\n</code></pre> <p>Finally, install the hooke package as follows: </p> <pre><code>devtools::install_github(\"cole-trapnell-lab/hooke\")\n</code></pre> <p>If you wish to install the develop branch of hooke, execute: </p> <pre><code>devtools::install_github(\"cole-trapnell-lab/hooke\", ref=\"develop\")\n</code></pre> <p>See our Github repository for more details.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#all-functions","title":"All functions","text":"<p><code>build_interval_formula()</code></p> <p>Builds a model formula for time series models based on the range of the data. This is a utility function that puts the knots in reasonable positions based on the range of the data.</p> <p><code>compare_abundances()</code></p> <p>Compare two estimates of cell abundances from a Hooke model.</p> <p><code>compare_ko_to_wt_at_timepoint()</code></p> <p>Helper function to plot kinetics</p> <p><code>estimate_abundances()</code></p> <p>Predict cell type abundances given a PLN model and a set of inputs for its covariates</p> <p><code>estimate_abundances_over_interval()</code></p> <p>Predict cell type abundances given a PLN model over a range of time or other interval</p> <p><code>new_cell_count_model()</code></p> <p>Create a new cell_count_model object.</p> <p><code>new_cell_count_set()</code></p> <p>Create a new cell_data_set object.</p> <p><code>plot_contrast()</code></p> <p>Plot a UMAP colored by how cells shift in a given contrast</p>"},{"location":"reference_brent/","title":"Reference brent","text":"<p>November 13, 2023</p>"},{"location":"reference_brent/#description","title":"DESCRIPTION","text":"<pre><code>Package: hooke\nTitle: Differential analysis of cell counts in single-cell experiments\nVersion: 0.0.1\nAuthors@R: \n    person(given = \"Madelein\",\n           family = \"Duran\",\n           role = c(\"aut\", \"cre\"),\n           email = \"duran@uw.edu\")\n    person(given = \"Cole\",\n           family = \"Trapnell\",\n           role = c(\"aut\", \"cre\"),\n           email = \"coletrap@uw.edu\")\nDescription: Hooke models abundances of different cell types and how they change in single-cell genomics experiments.\nLicense: MIT + file LICENSE\nEncoding: UTF-8\nLazyData: true\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.1\nLinkingTo: \n    Rcpp\nDepends:\n    Biobase, \n    monocle3,\n    PLNmodels\nImports:\n    assertthat (&gt;= 0.2.1),\n    batchelor,\n    BiocGenerics (&gt;= 0.28.0),\n    dplyr (&gt;= 0.8.0.1),\n    ggplot2 (&gt;= 3.1.1),\n    ggrepel (&gt;= 0.8.1),\n    grr,\n    igraph (&gt;= 1.2.4),\n    Matrix (&gt;= 1.2-17),\n    methods,\n    purrr (&gt;= 0.3.2),\n    RColorBrewer,\n    Rcpp (&gt;= 1.0.1),\n    S4Vectors,\n    stringr (&gt;= 1.4.0),\n    tibble (&gt;= 2.1.1),\n    tidyr (&gt;= 0.8.3),\n    viridis (&gt;= 0.5.1),\n    maxmatching,\n    Rgraphviz,\n    ggnetwork,\n    tidygraph,\n    ggforce,\n    ggnewscale\nSuggests: \n    testthat (&gt;= 2.1.0),\n    pryr (&gt;= 0.1.4),\n    knitr,\n    rmarkdown,\n    spelling\nVignetteBuilder: knitr\nLanguage: en-US```\n\n\n# `add_umap_coords`\n\nadds umap coords to a data frame\n\n\n## Description\n\nadds umap coords to a data frame\n\n\n## Usage\n\n```r\nadd_umap_coords(df, umap_centers)\n</code></pre>"},{"location":"reference_brent/#blacklist","title":"<code>blacklist</code>","text":"<p>return the complementing edges</p>"},{"location":"reference_brent/#description_1","title":"Description","text":"<p>return the complementing edges</p>"},{"location":"reference_brent/#usage","title":"Usage","text":"<pre><code>blacklist(edges)\n</code></pre>"},{"location":"reference_brent/#calc_max_flow","title":"<code>calc_max_flow</code>","text":"<p>Calculate max flow between two points</p>"},{"location":"reference_brent/#description_2","title":"Description","text":"<p>Calculate max flow between two points</p>"},{"location":"reference_brent/#usage_1","title":"Usage","text":"<pre><code>calc_max_flow(edges, source, target)\n</code></pre>"},{"location":"reference_brent/#calc_mst","title":"<code>calc_mst</code>","text":"<p>Calculate a minimum spanning tree</p>"},{"location":"reference_brent/#description_3","title":"Description","text":"<p>Calculate a minimum spanning tree</p>"},{"location":"reference_brent/#usage_2","title":"Usage","text":"<pre><code>calc_mst(edges, weight = \"pcor\")\n</code></pre>"},{"location":"reference_brent/#calc_shortest_path","title":"<code>calc_shortest_path</code>","text":"<p>Calculate the shortest path between two points</p>"},{"location":"reference_brent/#description_4","title":"Description","text":"<p>Calculate the shortest path between two points</p>"},{"location":"reference_brent/#usage_3","title":"Usage","text":"<pre><code>calc_shortest_path(G, from, to)\n</code></pre>"},{"location":"reference_brent/#arguments","title":"Arguments","text":"Argument Description <code>edges</code> data frame of edges with edge weights"},{"location":"reference_brent/#value","title":"Value","text":"<p>data frame containing the shortest path</p>"},{"location":"reference_brent/#cds","title":"<code>cds</code>","text":"<p>Get the underlying cell_data_set object from a cell_count_model.</p>"},{"location":"reference_brent/#description_5","title":"Description","text":"<p>Get the underlying cell_data_set object from a cell_count_model.</p>"},{"location":"reference_brent/#usage_4","title":"Usage","text":"<pre><code>cds(ccm)\n</code></pre>"},{"location":"reference_brent/#arguments_1","title":"Arguments","text":"Argument Description <code>ccm</code> A cell_count_model object."},{"location":"reference_brent/#value_1","title":"Value","text":"<p>A cell_data_set object</p>"},{"location":"reference_brent/#examples","title":"Examples","text":"<pre><code>cds(ccm)\n</code></pre>"},{"location":"reference_brent/#cell_count_model","title":"<code>cell_count_model</code>","text":"<p>The cell_count_model class</p>"},{"location":"reference_brent/#description_6","title":"Description","text":"<p>The main class used by Monocle3 to hold single-cell expression data.  cell_count_model extends the Bioconductor SingleCellExperiment class.</p>"},{"location":"reference_brent/#details","title":"Details","text":"<p>This class is initialized from a matrix of expression values along with cell  and feature metadata.</p>"},{"location":"reference_brent/#cell_count_set","title":"<code>cell_count_set</code>","text":"<p>The cell_count_set class</p>"},{"location":"reference_brent/#description_7","title":"Description","text":"<p>The main class used by Hooke to hold cell abundances data.  cell_count_set extends the Monocle's cell_data_set class.</p>"},{"location":"reference_brent/#details_1","title":"Details","text":"<p>This class is initialized from a matrix of expression values along with cell  and feature metadata.</p>"},{"location":"reference_brent/#centroids","title":"<code>centroids</code>","text":"<p>Get the centroids of cell groups in UMAP/PCA space.</p>"},{"location":"reference_brent/#description_8","title":"Description","text":"<p>Get the centroids of cell groups in UMAP/PCA space.</p>"},{"location":"reference_brent/#usage_5","title":"Usage","text":"<pre><code>centroids(ccs, reduction_method = \"UMAP\", switch_group = NULL)\n</code></pre>"},{"location":"reference_brent/#arguments_2","title":"Arguments","text":"Argument Description <code>ccs</code> A cell_count_set object."},{"location":"reference_brent/#value_2","title":"Value","text":"<p>A data frame of centroid coordinates</p>"},{"location":"reference_brent/#collect_pln_graph_edges","title":"<code>collect_pln_graph_edges</code>","text":"<p>Orient graph edges from a PLNnetwork using a contrast between conditions</p>"},{"location":"reference_brent/#description_9","title":"Description","text":"<p>Orient graph edges from a PLNnetwork using a contrast between conditions</p>"},{"location":"reference_brent/#usage_6","title":"Usage","text":"<pre><code>collect_pln_graph_edges(\n  ccm,\n  cond_b_vs_a_tbl,\n  log_abundance_thresh = 1 - 5,\n  model_for_pcors = \"reduced\"\n)\n</code></pre>"},{"location":"reference_brent/#arguments_3","title":"Arguments","text":"Argument Description <code>ccm</code> A cell_count_model <code>cond_b_vs_a_tbl</code> A contrast between two conditions as returned by compare_abundances()"},{"location":"reference_brent/#compare_abundances","title":"<code>compare_abundances</code>","text":"<p>Compare two estimates of cell abundances from a Hooke model</p>"},{"location":"reference_brent/#description_10","title":"Description","text":"<p>Compare two estimates of cell abundances from a Hooke model</p>"},{"location":"reference_brent/#usage_7","title":"Usage","text":"<pre><code>compare_abundances(ccm, cond_x, cond_y, method = \"BH\")\n</code></pre>"},{"location":"reference_brent/#arguments_4","title":"Arguments","text":"Argument Description <code>ccm</code> A cell_count_model <code>cond_x</code> An estimate from estimate_abundances() <code>cond_y</code> An estimate from estimate_abundances()"},{"location":"reference_brent/#value_3","title":"Value","text":"<p>A table contrasting cond_x and cond_y (interpret as Y/X)</p>"},{"location":"reference_brent/#estimate_abundances","title":"<code>estimate_abundances</code>","text":"<p>Predict cell type abundances given a PLN model and a set of inputs for its covariates</p>"},{"location":"reference_brent/#description_11","title":"Description","text":"<p>Predict cell type abundances given a PLN model and a set of inputs for its covariates</p>"},{"location":"reference_brent/#usage_8","title":"Usage","text":"<pre><code>estimate_abundances(ccm, newdata, min_log_abund = -5)\n</code></pre>"},{"location":"reference_brent/#arguments_5","title":"Arguments","text":"Argument Description <code>newdata</code> needs to be suitable input to pln_model"},{"location":"reference_brent/#get_paga_graph","title":"<code>get_paga_graph</code>","text":"<p>Extract a partitioned abstract graph from a Monocle cell_data_set object</p>"},{"location":"reference_brent/#description_12","title":"Description","text":"<p>QUESTION: Do the cells need to be grouped by monocle cluster? Or can they  be grouped arbitrarily (e.g. by cell type? Would be good to generalize if  possible. For now, only works when cells are grouped by Monocle cluster</p>"},{"location":"reference_brent/#usage_9","title":"Usage","text":"<pre><code>get_paga_graph(cds, reduction_method = \"UMAP\")\n</code></pre>"},{"location":"reference_brent/#arguments_6","title":"Arguments","text":"Argument Description <code>cds</code> A cell_data_set object. cluster_cells() must have been called. <code>reduction_method</code> The coordinate space in which to build the graph"},{"location":"reference_brent/#get_pcor_edges","title":"<code>get_pcor_edges</code>","text":"<p>returns edges based on pcor values</p>"},{"location":"reference_brent/#description_13","title":"Description","text":"<p>returns edges based on pcor values</p>"},{"location":"reference_brent/#usage_10","title":"Usage","text":"<pre><code>get_pcor_edges(ccm, selected_model = c(\"reduced\", \"full\"))\n</code></pre>"},{"location":"reference_brent/#hello","title":"<code>hello</code>","text":"<p>Hello, World!</p>"},{"location":"reference_brent/#description_14","title":"Description","text":"<p>Prints 'Hello, world!'.</p>"},{"location":"reference_brent/#usage_11","title":"Usage","text":"<pre><code>hello()\n</code></pre>"},{"location":"reference_brent/#examples_1","title":"Examples","text":"<pre><code>hello()\n</code></pre>"},{"location":"reference_brent/#init_penalty_matrix","title":"<code>init_penalty_matrix</code>","text":"<p>Initialize the PLN network penalty matrix, accepting optional whitelists and  blacklists of edges that are \"free\" or \"off limits\" between cell groups</p>"},{"location":"reference_brent/#description_15","title":"Description","text":"<p>Initialize the PLN network penalty matrix, accepting optional whitelists and  blacklists of edges that are \"free\" or \"off limits\" between cell groups</p>"},{"location":"reference_brent/#usage_12","title":"Usage","text":"<pre><code>init_penalty_matrix(\n  ccs,\n  whitelist = NULL,\n  blacklist = NULL,\n  base_penalty = 1,\n  min_penalty = 0.01,\n  max_penalty = 1e+06\n)\n</code></pre>"},{"location":"reference_brent/#arguments_7","title":"Arguments","text":"Argument Description <code>ccs</code> A cell_count_set of aggregated cell counts <code>whitelist</code> a data frame with two columns corresponding to (undirected) edges that should receive no penalty <code>blacklist</code> a data frame with two columns corresponding to (undirected) edges that should receive very high penalty <code>dist_fun</code> A function that returns a penalty based given a distance between two clusters"},{"location":"reference_brent/#model","title":"<code>model</code>","text":"<p>Get the selected PLNnetwork from a cell_count_model object.</p>"},{"location":"reference_brent/#description_16","title":"Description","text":"<p>Get the selected PLNnetwork from a cell_count_model object.</p>"},{"location":"reference_brent/#usage_13","title":"Usage","text":"<pre><code>model(ccm, model_to_return = c(\"full\", \"reduced\"))\n</code></pre>"},{"location":"reference_brent/#arguments_8","title":"Arguments","text":"Argument Description <code>ccm</code> A cell_count_model object."},{"location":"reference_brent/#value_4","title":"Value","text":"<p>An updated cell_count_model object</p>"},{"location":"reference_brent/#examples_2","title":"Examples","text":"<pre><code>model(ccm)\n</code></pre>"},{"location":"reference_brent/#new_cell_count_model","title":"<code>new_cell_count_model</code>","text":"<p>Create a new cell_count_model object.</p>"},{"location":"reference_brent/#description_17","title":"Description","text":"<p>Fits a PLNnetwork according to a formula. Accepts a matrix of penalties as a  way of encoding a graph prior. Automatically selects sparsity parameter, but  allows user to update it.</p>"},{"location":"reference_brent/#usage_14","title":"Usage","text":"<pre><code>new_cell_count_model(\n  ccs,\n  main_model_formula_str,\n  nuisance_model_formula_str = \"1\",\n  penalty_matrix = NULL,\n  whitelist = NULL,\n  blacklist = NULL,\n  sparsity_factor = 0.1,\n  base_penalty = 1,\n  min_penalty = 0.01,\n  max_penalty = 1e+06,\n  verbose = FALSE,\n  pseudocount = 0,\n  pln_min_ratio = 0.001,\n  pln_num_penalties = 30,\n  size_factors = NULL,\n  ...\n)\n</code></pre>"},{"location":"reference_brent/#arguments_9","title":"Arguments","text":"Argument Description <code>ccs</code> A Hooke cell_count_set object. <code>main_model_formula_str</code> A character string specifying the model of cell abundances across samples, where terms refer to columns in <code>colData(ccs)</code> . Put main effects here. <code>nuisance_model_formula_str</code> A character string specifying the model of cell abundances across samples. Put nuisance effects here. <code>penalty_matrix</code> A numeric NxN symmetric matrix specifying penalties for the PLN model, where N is the number of cell types. Entries must be positive. Use to specify an undirected graph prior for the PLN model. <code>sparsity_factor</code> A positive number to control how sparse the PLN network is. Larger values make the network more sparse."},{"location":"reference_brent/#value_5","title":"Value","text":"<p>a new cell_count_model object</p>"},{"location":"reference_brent/#new_cell_count_set","title":"<code>new_cell_count_set</code>","text":"<p>Create a new cell_data_set object.</p>"},{"location":"reference_brent/#description_18","title":"Description","text":"<p>Create a new cell_data_set object.</p>"},{"location":"reference_brent/#usage_15","title":"Usage","text":"<pre><code>new_cell_count_set(\n  cds,\n  sample_group,\n  cell_group,\n  sample_metadata = NULL,\n  cell_metadata = NULL,\n  lower_threshold = NULL,\n  upper_threshold = NULL\n)\n</code></pre>"},{"location":"reference_brent/#arguments_10","title":"Arguments","text":"Argument Description <code>cds</code> A Monocle cell data set object. <code>sample_group</code> A column in colData(cds) that specifes how cells are grouped into samples <code>cell_group</code> A column in colData(cds) that specifies how cells are grouped into types or states (e.g. cluster) <code>sample_metadata</code> data frame containing attributes of individual samples, where <code>cell_metadata</code> data frame containing attributes of individual cell groups, where <code>row.names(cell_metadata)</code> are entries in <code>cell_group</code>"},{"location":"reference_brent/#value_6","title":"Value","text":"<p>a new cell_data_set object</p>"},{"location":"reference_brent/#plot_contrast","title":"<code>plot_contrast</code>","text":"<p>Plot a UMAP colored by how cells shift in a given contrast</p>"},{"location":"reference_brent/#description_19","title":"Description","text":"<p>Plot a UMAP colored by how cells shift in a given contrast</p>"},{"location":"reference_brent/#usage_16","title":"Usage","text":"<pre><code>plot_contrast(\n  ccm,\n  cond_b_vs_a_tbl,\n  log_abundance_thresh = -5,\n  scale_shifts_by = c(\"receiver\", \"sender\", \"none\"),\n  edge_size = 2,\n  cell_size = 1,\n  q_value_thresh = 1,\n  group_label_size = 2,\n  plot_labels = c(\"significant\", \"all\", \"none\"),\n  fc_limits = c(-3, 3),\n  sender_cell_groups = NULL,\n  receiver_cell_groups = NULL,\n  plot_edges = c(\"all\", \"directed\", \"undirected\", \"none\"),\n  label_cell_groups = list(),\n  repel_labels = TRUE,\n  model_for_pcors = \"reduced\",\n  switch_label = NULL,\n  sub_cds = NULL,\n  alpha = 1,\n  x = 1,\n  y = 2\n)\n</code></pre>"},{"location":"reference_brent/#arguments_11","title":"Arguments","text":"Argument Description <code>ccm</code> A cell_count_model object. <code>criterion</code> a character string specifying the PLNmodels criterion to use. Must be one of \"BIC\", \"EBIC\" or \"StARS\"."},{"location":"reference_brent/#value_7","title":"Value","text":"<p>an updated cell_count_model object</p>"},{"location":"reference_brent/#select_model","title":"<code>select_model</code>","text":"<p>Select the model a cell_count_model should use</p>"},{"location":"reference_brent/#description_20","title":"Description","text":"<p>Select the model a cell_count_model should use</p>"},{"location":"reference_brent/#usage_17","title":"Usage","text":"<pre><code>select_model(\n  ccm,\n  criterion = \"EBIC\",\n  sparsity_factor = 1,\n  models_to_update = c(\"both\", \"full\", \"reduced\")\n)\n</code></pre>"},{"location":"reference_brent/#arguments_12","title":"Arguments","text":"Argument Description <code>ccm</code> A cell_count_model object. <code>criterion</code> a character string specifying the PLNmodels criterion to use. Must be one of \"BIC\", \"EBIC\" or \"StARS\"."},{"location":"reference_brent/#value_8","title":"Value","text":"<p>an updated cell_count_model object</p>"},{"location":"reference/build_interval_formula/","title":"Build interval formula","text":"<p>Builds a model formula for time series models based on the range of the data. This is a utility function that puts the knots in reasonable positions based on the range of the data.</p> <pre><code>build_interval_formula(\n  ccs,\n  num_breaks,\n  interval_var = \"timepoint\",\n  interval_start = NULL,\n  interval_stop = NULL\n)\n</code></pre>"},{"location":"reference/build_interval_formula/#arguments","title":"Arguments","text":"<p>character</p> <p>interval_var</p> <p>numeric</p> <p>interval_stop Interval stop value.</p>"},{"location":"reference/build_interval_formula/#value","title":"Value","text":"<p>An interval model formula.</p>"},{"location":"reference/compare_abundances/","title":"Compare abundances","text":"<p>Compare two estimates of cell abundances from a Hooke model.</p> <pre><code>compare_abundances(\n  ccm,\n  cond_x,\n  cond_y,\n  method = c(\"BH\", \"bonferroni\", \"hochberg\", \"hommel\", \"BY\")\n)\n</code></pre>"},{"location":"reference/compare_abundances/#arguments","title":"Arguments","text":"<p>ccm</p> <p>A cell_count_model.</p> <p>cond_x</p> <p>tibble A cell type abundance estimate from estimate_abundances().</p> <p>cond_y</p> <p>tibble A cell type abundance estimate from estimate from estimate_abundances().</p> <p>method</p> <p>string A method for correcting P-value multiple comparisons. This can be \"BH\" (Benjamini &amp; Hochberg), \"bonferroni\" (Bonferroni), \"hochberg\" (Hochberg), \"hommel\", (Hommel), or \"BYH\" (Benjamini &amp; Yekutieli).</p>"},{"location":"reference/compare_abundances/#value","title":"Value","text":"<p>tibble A table contrasting cond_x and cond_y (interpret as Y/X).</p>"},{"location":"reference/compare_ko_to_wt_at_timepoint/","title":"Compare ko to wt at timepoint","text":"<p>Helper function to plot kinetics</p> <pre><code>compare_ko_to_wt_at_timepoint(\n  tp,\n  perturbation_ccm,\n  wt_pred_df,\n  ko_pred_df,\n  interval_col\n)\n</code></pre>"},{"location":"reference/compare_ko_to_wt_at_timepoint/#arguments","title":"Arguments","text":"<p>tp</p> <p>timepoint</p> <p>perturbation_ccm</p> <p>a cell count model with a perturbation</p> <p>wt_pred_df</p> <p>control output from estimate_abundances_over_interval()</p> <p>ko_pred_df</p> <p>perturbation output from estimate_abundances_over_interval()</p> <p>interval_col</p> <p>column that matches the timepoint information</p>"},{"location":"reference/estimate_abundances/","title":"Estimate abundances","text":"<p>Predict cell type abundances given a PLN model and a set of inputs for its covariates</p> <pre><code>estimate_abundances(ccm, newdata, min_log_abund = -5)\n</code></pre>"},{"location":"reference/estimate_abundances/#arguments","title":"Arguments","text":"<p>ccm</p> <p>A cell_count_model.</p> <p>newdata</p> <p>tibble A tibble of variables used for the prediction.</p> <p>min_log_abund</p> <p>numeric Minimum log abundance value.</p>"},{"location":"reference/estimate_abundances/#value","title":"Value","text":"<p>A tibble of cell abundance predictions.</p>"},{"location":"reference/estimate_abundances_over_interval/","title":"Estimate abundances over interval","text":"<p>Predict cell type abundances given a PLN model over a range of time or other interval</p> <pre><code>estimate_abundances_over_interval(\n  ccm,\n  interval_start,\n  interval_stop,\n  interval_col = \"timepoint\",\n  interval_step = 2,\n  min_log_abund = -5,\n  ...\n)\n</code></pre>"},{"location":"reference/estimate_abundances_over_interval/#arguments","title":"Arguments","text":"<p>ccm</p> <p>A cell_count_model.</p> <p>interval_start</p> <p>numeric Interval start value.</p> <p>interval_stop</p> <p>numeric Interval stop value.</p> <p>interval_col</p> <p>character Interval values are taken from the interval_var data. Default is \"timepoint\".</p> <p>interval_step</p> <p>numeric Interval size. Default is 2.</p>"},{"location":"reference/estimate_abundances_over_interval/#value","title":"Value","text":"<p>A tibble of cell abundance predictions.</p>"},{"location":"reference/new_cell_count_model/","title":"New cell count model","text":"<p>Fits a PLNnetwork according to a formula. Accepts a matrix of penalties as a way of encoding a graph prior. Automatically selects sparsity parameter, but allows user to update it.</p> <pre><code>new_cell_count_model(\n  ccs,\n  main_model_formula_str,\n  nuisance_model_formula_str = \"1\",\n  penalty_matrix = NULL,\n  whitelist = NULL,\n  blacklist = NULL,\n  sparsity_factor = 0.1,\n  base_penalty = 1,\n  min_penalty = 0.01,\n  max_penalty = 1e+06,\n  verbose = FALSE,\n  pseudocount = 0,\n  pln_min_ratio = 0.001,\n  pln_num_penalties = 30,\n  vhat_method = c(\"bootstrap\", \"variational_var\", \"jackknife\"),\n  covariance_type = c(\"spherical\", \"diagonal\"),\n  num_bootstraps = 10,\n  inception = NULL,\n  backend = c(\"nlopt\", \"torch\"),\n  num_threads = 1,\n  ftol_rel = 1e-06,\n  penalize_by_distance = TRUE,\n  penalty_scale_exponent = 2,\n  reduction_method = \"UMAP\",\n  ...\n</code></pre> <p>)</p> <p>Arguments</p> <pre><code>ccs\n</code></pre> <p>A Hooke cell_count_set object.</p> <p>main_model_formula_str</p> <p>A character string specifying the model of cell abundances across samples, where terms refer to columns in<code>colData(ccs)</code>. Put main effects here.</p> <p>nuisance_model_formula_str</p> <p>A character string specifying the model of cell abundances across samples. Put nuisance effects here.</p> <p>penalty_matrix</p> <p>A numeric NxN symmetric matrix specifying penalties for the PLN model, where N is the number of cell types. Entries must be positive and the rows and columns must be named with the cell_group names. Use to specify an undirected graph prior for the PLN model.</p> <p>whitelist</p> <p>list A data frame with two columns corresponding to (undirected) edges that should receive min_penalty. The columns are integers that refer to cell clusters.</p> <p>blacklist</p> <p>list A data frame with two columns corresponding to (undirected) edges that should receive max_penalty. The columns are integers that refer to cell clusters.</p> <p>sparsity_factor</p> <p>A positive number to control how sparse the PLN network is. Larger values make the network more sparse. edges that should receive min_penalty. The columns are either cell_group names or integers that refer to cell_groups in penalty_matrix.</p> <p>base_penalty</p> <p>numeric A factor that scales the penalty matrix.</p> <p>min_penalty</p> <p>numeric A positive value that is assigned to whitelisted penalty matrix elements, which over-write existing values.</p> <p>max_penalty</p> <p>numeric A positive value that is assigned to blacklisted penalty matrix elements. which over-write existing values.</p> <p>verbose</p> <p>logical Whether to emit verbose output.</p> <p>pseudocount</p> <p>integer A value added to the elements of the initial cell_count_set matrix.</p> <p>pln_min_ratio</p> <p>numeric Used in the definition of the sparsity penalty grid.</p> <p>pln_num_penalties</p> <p>integer Number of penalty values for the internally generated penalty grid.</p> <p>vhat_method</p> <p>string Method used to compute covariance matrix?</p> <pre><code>num\\_bootstraps\n</code></pre> <p>positive integer Number of iterations used with the bootstrap vhat_method.</p> <p>inception</p> <p>Not used.</p> <p>backend</p> <p>Method used to run bootstrap iterations.</p> <p>Value</p> <pre><code>a new cell\\_count\\_model object\n</code></pre>"},{"location":"reference/new_cell_count_set/","title":"New cell count set","text":"<p>Create a new cell_data_set object.</p> <pre><code>new_cell_count_set(\n  cds,\n  sample_group,\n  cell_group,\n  sample_metadata = NULL,\n  cell_metadata = NULL,\n  lower_threshold = NULL,\n  upper_threshold = NULL,\n  keep_cds = TRUE,\n  norm_method = c(\"size_factors\", \"TSS\", \"CSS\", \"RLE\", \"GMPR\", \"Wrench\", \"none\"),\n  size_factors = NULL,\n  pseudocount = 0\n)\n</code></pre>"},{"location":"reference/new_cell_count_set/#arguments","title":"Arguments","text":"<p>cds</p> <p>A Monocle cell data set object.</p> <p>sample_group</p> <p>A column in colData(cds) that specifes how cells are grouped into samples.</p> <p>cell_group</p> <p>A column in colData(cds) that specifies how cells are grouped into types or states (e.g. cluster).</p> <p>sample_metadata</p> <p>Data frame containing attributes of individual samples, where the column named 'sample' has entries in <code>sample_group</code>.</p> <p>cell_metadata</p> <p>Data frame containing attributes of individual cell groups, where <code>row.names(cell_metadata)</code> are entries in <code>cell_group</code></p> <p>lower_threshold</p> <p>numeric Minimum number of cells in retained cell_groups.</p> <p>upper_threshold</p> <p>numeric Maximum number of cells in retained cell_groups.</p> <p>norm_method</p> <p>string Normalization method used to compute scaling factors used as offset during PLN inference.</p> <p>size_factors</p> <p>numeric vector or matrix User supplied vector or matrix of offsets passed the PLNmodels::prepare_data() method.</p>"},{"location":"reference/new_cell_count_set/#value","title":"Value","text":"<p>a new cell_data_set object</p>"},{"location":"reference/plot_contrast/","title":"Plot contrast","text":"<p>Plot a UMAP colored by how cells shift in a given contrast</p> <pre><code>plot_contrast(\n  ccm,\n  cond_b_vs_a_tbl,\n  log_abundance_thresh = -5,\n  scale_shifts_by = c(\"receiver\", \"sender\", \"none\"),\n  edge_size = 2,\n  cell_size = 1,\n  q_value_thresh = 1,\n  group_label_size = 2,\n  plot_labels = c(\"significant\", \"all\", \"none\"),\n  fc_limits = c(-3, 3),\n  sender_cell_groups = NULL,\n  receiver_cell_groups = NULL,\n  plot_edges = c(\"none\", \"all\", \"directed\", \"undirected\"),\n  edge_significance = c(\"both\", \"one-sided\"),\n  keep_colors = FALSE,\n  label_cell_groups = list(),\n  repel_labels = TRUE,\n  model_for_pcors = c(\"reduced\", \"full\"),\n  switch_label = NULL,\n  sub_cds = NULL,\n  alpha = 1,\n  x = 1,\n  y = 2\n)\n</code></pre>"},{"location":"reference/plot_contrast/#arguments","title":"Arguments","text":"<p>ccm</p> <p>A cell_count_model object.</p> <p>cond_b_vs_a_tbl</p> <p>data.frame A data frame from compare_abundances.</p> <p>log_abundance_thresh</p> <p>numeric Select cell groups by log abundance.</p> <p>scale_shifts_by</p> <p>string A scale directed graph edges by \"sender\", \"receiver\", or \"none\".</p> <p>edge_size</p> <p>numeric The size of edges in the plot.</p> <p>cell_size</p> <p>numeric The size of cells in the plot.</p> <p>q_value_thresh</p> <p>numeric Remove contrasts whose change in q-value exceeds q_value_thresh.</p> <p>group_label_size</p> <p>numeric The size of group labels in the plot.</p> <p>plot_labels</p> <p>string Choose cell groups to label.</p> <p>fc_limits</p> <p>vector The range of cell abundance changes to include in the plot.</p> <p>sender_cell_groups</p> <p>list Sender cell groups of directed graph.</p> <p>receiver_cell_groups</p> <p>list Receiver cell groups of directed graph.</p> <p>plot_edges</p> <p>string Type of edges to plot.</p> <p>label_cell_groups</p> <p>list The cell_group labels to include in the plot.</p> <p>repel_labels</p> <p>logical Repel overlapping plot labels.</p> <p>model_for_pcors</p> <p>string The model to use for orienting graph edges from the PLNnetwork.</p> <p>switch_label</p> <p>string The name of the cell_data_set column with cell_group identifiers.</p> <p>sub_cds</p> <p>string A cell_data_set.</p> <p>alpha</p> <p>numeric A the ggplot opacity. A value between 0 and 1.</p> <p>x</p> <p>numeric The column number for the UMAP x coordinate.</p> <p>y</p> <p>numeric The column number for the UMAP y coordinate.</p>"},{"location":"reference/plot_contrast/#value","title":"Value","text":"<p>A ggplot2 plot object.</p>"}]}